/**
 *  Original Description:
 *
 *     A simple sequence of N processes arranged in a linear pipe:
 *     every process knows only the next in the row and forwards everything to it.
 *
 *     A property Soter can prove is that the mailbox of each `pipe_node`
 *     contains at most 1 message at any given time.
 *
 *     Adapted from [(Kobayashi, Nakade and Yonezawa, 1995)](http://dx.doi.org/10.1007/3-540-60360-3_42)
 */
target C {
    verification: {
        engine: uclid,
        induction: 2
    }
};

reactor Node {
    
    input  in:int;
    output out:int;
    
    state  count:int;
    state  payload:int;

    logical action send_output;
    
    // @inv(payload == in 
    //     /\ count == (prev(count) + 1) 
    //     /\ F[reaction[2] /\ at(0 sec)])
    reaction(in) -> send_output {=
        self->payload = in->value;
        self->count++;
        schedule(send_output, 0);
    =}

    // @inv(out == payload
    //     /\ count == (prev(count) - 1))
    reaction(send_output) -> out {=
        SET(out, self->payload);
        self->count--;
    =}
}

// FIXME: Not passing since the consecution step assume state is initially 1. How to fix this?
// Soln: Add an auxiliary invariant that says when pipe_reaction_0 triggers, node_1_count is 0.
//
// TODOs from this small example:
// 1. Make sure to add grammar to express "produces output."
// 2. Make sure the default behavior for NULL is not outputting value.
// 3. Make sure for consecution step, we should disable NULL in the first state, otherwise 1-induction sometimes does not work. See the example if you make steps 6.
//
// LTL: G(node_1.count <= 1)
// @property("count_leq_1", "pipe_node_1_count(s(i)) <= 1")
// @bound("count_leq_1", 4)
// @aux("count_leq_1", "pipe_node_1_count(s(i)) >= 0")
// @aux("count_leq_1", "rxn(i) == pipe_reaction_0 ==> pipe_node_1_count(s(i)) == 0")
//
// @property("count_leq_1", 
//     node_1.count <= 1
//     /\ node_2.count <= 1
//     /\ node_3.count <= 1
//     /\ node_4.count <= 1
//     /\ node_5.count <= 1
// )
// @bound("count_leq_1", 20)
// @aux("count_leq_1", reaction[1] ==> [node_1.count == 0])
// @property("test", false)
// @bound("test", 2)
// @property("count",
//     ![node_1.count <= 1
//     /\ node_2.count <= 1]
// )
// @property("count",false)
// @bound("count", 7)
main reactor {
    
    node_1 = new Node();
    node_2 = new Node();
    // node_3 = new Node();
    // node_4 = new Node();
    // node_5 = new Node();

    node_1.out -> node_2.in after 1 sec;
    // node_2.out -> node_3.in after 1 sec;
    // node_3.out -> node_4.in after 1 sec;
    // node_4.out -> node_5.in after 1 sec;

    timer t(0, 1 sec);
    state value:int(0);

    // @inv(node_1.in == value
    //     /\ value == (prev(value) + 1)
    //     /\ F[node_1.reaction[1] /\ simultaneous])
    // @inv(node_1.in == value
    //     /\ value == (prev(value) + 1))
    // FIXME: Why does the contraint below blocks the solver?
    // @inv(set(node_1.in, value) /\ value == prev(value) + 1)
    reaction(t) -> node_1.in {=
        SET(node_1.in, self->value++);
    =}

    reaction(node_2.out) {=
        printf("Received after pipeline: %d\n", node_2.out->value);
    =}
}