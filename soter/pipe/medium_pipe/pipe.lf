/**
 *  Original Description:
 *
 *     A simple sequence of N processes arranged in a linear pipe:
 *     every process knows only the next in the row and forwards everything to it.
 *
 *     A property Soter can prove is that the mailbox of each `pipe_node`
 *     contains at most 1 message at any given time.
 *
 *     Adapted from [(Kobayashi, Nakade and Yonezawa, 1995)](http://dx.doi.org/10.1007/3-540-60360-3_42)
 */
target C {
    verification: {
        engine: uclid,
        induction: 3
    }
};

reactor Source {

    output out:int;
    logical action _timer(900 msec):int;

    @inv(set(out, 1))
    @inv(schedule(_timer, 0))
    reaction(startup, _timer) -> out, _timer {=
        SET(out, 1);
        schedule(_timer, 0);
    =}
}

reactor Sink {
    input in:int;
    reaction(in) {=
        printf("Received after pipeline: %d\n", in->value);
    =}
}

reactor Node {
    
    input  in:int;
    output out:int;
    
    state  count:int;
    state  payload:int;

    logical action send_output:int;

    @inv(payload == in)
    @inv(count == (prev(count) + 1))
    @inv(schedule(send_output, 0)) // Dummy payload
    reaction(in) -> send_output {=
        self->payload = in->value;
        self->count++;
        schedule(send_output, 0);
    =}

    @inv(set(out, 1)) // FIXME: make it reference payload
    @inv(count == (prev(count) - 1))
    reaction(send_output) -> out {=
        SET(out, self->payload);
        self->count--;
    =}
}

@property("count", false)
@bound("count", 5)
main reactor {
    
    source = new Source();
    sink = new Sink();
    node_1 = new Node();

    // source.out -> sink.in after 1 sec;
    source.out -> node_1.in after 1 sec;
    node_1.out -> sink.in;
}