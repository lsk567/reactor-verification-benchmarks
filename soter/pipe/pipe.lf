/**
 *  Original Description:
 *
 *     A simple sequence of N processes arranged in a linear pipe:
 *     every process knows only the next in the row and forwards everything to it.
 *
 *     A property Soter can prove is that the mailbox of each `pipe_node`
 *     contains at most 1 message at any given time.
 *
 *     Adapted from [(Kobayashi, Nakade and Yonezawa, 1995)](http://dx.doi.org/10.1007/3-540-60360-3_42)
 */

target C {
    verification: {
        engine: uclid,
        steps: 7
    }
};

reactor Node1 {
    
    input  in:int;
    output out:int;
    
    state  count:int;
    state  payload:int;

    logical action send_output;
    
    // MTL: payload == in /\ count == prev(count) + 1 /\ F[1 mstep](reaction_1)
    // @inv("pipe_node_1_payload(s(i)) == pipe_node_1_in(s(i)) && pipe_node_1_count(s(i)) == pipe_node_1_count(s(i-1)) + 1 && (exists (j : integer) :: j > i && j <= END && rxn(j) == pipe_node_1_reaction_1)")
    @inv("pipe_node_1_payload(s(i)) == pipe_node_1_in(s(i)) && pipe_node_1_count(s(i)) == pipe_node_1_count(s(i-1)) + 1 && (exists (j : integer) :: j > i && j <= END && rxn(j) == pipe_node_1_reaction_1 && g(j) == tag_schedule(g(i), zero())) && true && pipe_value(s(i)) == pipe_value(s(i-1)) && pipe_node_1_out(s(i)) == pipe_node_1_out(s(i-1))")
    reaction(in) -> send_output {=
        self->payload = in->value;
        self->count++;
        schedule(send_output, 0);
    =}

    // MTL: out == payload /\ count == prev(count) - 1
    // @inv("pipe_node_1_out(s(i)) == pipe_node_1_payload(s(i)) && pipe_node_1_count(s(i)) == pipe_node_1_count(s(i-1)) - 1")
    @inv("pipe_node_1_out(s(i)) == pipe_node_1_payload(s(i)) && pipe_node_1_count(s(i)) == pipe_node_1_count(s(i-1)) - 1 && true && pipe_value(s(i)) == pipe_value(s(i-1)) && pipe_node_1_in(s(i)) == pipe_node_1_in(s(i-1))")
    reaction(send_output) -> out {=
        SET(out, self->payload);
        self->count--;
    =}
}

/*
reactor Node2 {
    
    input  in:int;
    output out:int;
    
    state  count:int;
    state  payload:int;

    logical action send_output;
    
    // MTL: payload == in /\ count == prev(count) + 1 /\ F[1 mstep](reaction_1)
    @inv("pipe_node_2_payload(s(i)) == pipe_node_2_in(s(i)) && pipe_node_2_count(s(i)) == pipe_node_2_count(s(i-1)) + 1 && (exists (j : integer) :: j > i && j <= END && rxn(j) == pipe_node_2_reaction_1)")
    reaction(in) -> send_output {=
        self->payload = in->value;
        self->count++;
        schedule(send_output, 0);
    =}

    // MTL: out == payload /\ count == prev(count) - 1
    @inv("pipe_node_2_out(s(i)) == pipe_node_2_payload(s(i)) && pipe_node_2_count(s(i)) == pipe_node_2_count(s(i-1)) - 1")
    reaction(send_output) -> out {=
        SET(out, self->payload);
        self->count--;
    =}
}

reactor Node3 {
    
    input  in:int;
    output out:int;
    
    state  count:int;
    state  payload:int;

    logical action send_output;
    
    // MTL: payload == in /\ count == prev(count) + 1 /\ F[1 mstep](reaction_1)
    @inv("pipe_node_3_payload(s(i)) == pipe_node_3_in(s(i)) && pipe_node_3_count(s(i)) == pipe_node_3_count(s(i-1)) + 1 && (exists (j : integer) :: j > i && j <= END && rxn(j) == pipe_node_3_reaction_1)")
    reaction(in) -> send_output {=
        self->payload = in->value;
        self->count++;
        schedule(send_output, 0);
    =}

    // MTL: out == payload /\ count == prev(count) - 1
    @inv("pipe_node_3_out(s(i)) == pipe_node_3_payload(s(i)) && pipe_node_3_count(s(i)) == pipe_node_3_count(s(i-1)) - 1")
    reaction(send_output) -> out {=
        SET(out, self->payload);
        self->count--;
    =}
}

reactor Node4 {
    
    input  in:int;
    output out:int;
    
    state  count:int;
    state  payload:int;

    logical action send_output;
    
    // MTL: payload == in /\ count == prev(count) + 1 /\ F[1 mstep](reaction_1)
    @inv("pipe_node_4_payload(s(i)) == pipe_node_4_in(s(i)) && pipe_node_4_count(s(i)) == pipe_node_4_count(s(i-1)) + 1 && (exists (j : integer) :: j > i && j <= END && rxn(j) == pipe_node_4_reaction_1)")
    reaction(in) -> send_output {=
        self->payload = in->value;
        self->count++;
        schedule(send_output, 0);
    =}

    // MTL: out == payload /\ count == prev(count) - 1
    @inv("pipe_node_4_out(s(i)) == pipe_node_4_payload(s(i)) && pipe_node_4_count(s(i)) == pipe_node_4_count(s(i-1)) - 1")
    reaction(send_output) -> out {=
        SET(out, self->payload);
        self->count--;
    =}
}

reactor Node5 {
    
    input  in:int;
    output out:int;
    
    state  count:int;
    state  payload:int;

    logical action send_output;
    
    // MTL: payload == in /\ count == prev(count) + 1 /\ F[1 mstep](reaction_1)
    @inv("pipe_node_5_payload(s(i)) == pipe_node_5_in(s(i)) && pipe_node_5_count(s(i)) == pipe_node_5_count(s(i-1)) + 1 && (exists (j : integer) :: j > i && j <= END && rxn(j) == pipe_node_5_reaction_1)")
    reaction(in) -> send_output {=
        self->payload = in->value;
        self->count++;
        schedule(send_output, 0);
    =}

    // MTL: out == payload /\ count == prev(count) - 1
    @inv("pipe_node_5_out(s(i)) == pipe_node_5_payload(s(i)) && pipe_node_5_count(s(i)) == pipe_node_5_count(s(i-1)) - 1")
    reaction(send_output) -> out {=
        SET(out, self->payload);
        self->count--;
    =}
}
*/

// MTL: G(node_1.count <= 1 /\ node_2.count <= 1 /\ node_3.count <= 1 /\ node_4.count <= 1 /\ node_5.count <= 1)
// Auxiliary invariant is added after "true."
// @property("pipe_node_1_count(s(i)) <= 1 && pipe_node_2_count(s(i)) <= 1 && pipe_node_3_count(s(i)) <= 1 && pipe_node_4_count(s(i)) <= 1 && pipe_node_5_count(s(i)) <= 1 && true && pipe_node_1_count(s(i)) >= 0 && pipe_node_2_count(s(i)) >= 0 && pipe_node_3_count(s(i)) >= 0 && pipe_node_4_count(s(i)) >= 0 && pipe_node_5_count(s(i)) >= 0", 11)
// FIXME: Not passing since the consecution step assume state is initially 1. How to fix this?
// Also make sure to add grammar to express "produces output."
// Also make sure the default behavior for NULL is not outputting value.
// Also make sure for consecution step, we should disable NULL in the first state, otherwise 1-induction sometimes does not work. See the example if you make steps 6.
@property("(pipe_node_1_count(s(i)) <= 1 && true && pipe_node_1_count(s(i)) >= 0 && (rxn(i) == pipe_reaction_0 ==> pipe_node_1_count(s(i)) == 0))", 4)
main reactor {
    
    node_1 = new Node1();
    // node_2 = new Node2();
    // node_3 = new Node3();
    // node_4 = new Node4();
    // node_5 = new Node5();

    timer t(0, 1 sec);
    state value:int(0);

    // MTL: F[0](node_1.reaction_0)
    // FIXME: need to specify that all the other variables do not change.
    @inv("pipe_node_1_in(s(i)) == pipe_value(s(i)) && pipe_value(s(i)) == pipe_value(s(i-1)) + 1 && (exists (j : integer) :: j > i && j <= END && rxn(j) == pipe_node_1_reaction_0 && g(j) == g(i)) && true && pipe_node_1_count(s(i)) == pipe_node_1_count(s(i-1)) && pipe_node_1_payload(s(i)) == pipe_node_1_payload(s(i-1)) && pipe_node_1_out(s(i)) == pipe_node_1_out(s(i-1))")
    reaction(t) -> node_1.in {=
        SET(node_1.in, self->value++);
    =}

    // node_1.out -> node_2.in after 1 sec;
    // node_2.out -> node_3.in after 1 sec;
    // node_3.out -> node_4.in after 1 sec;
    // node_4.out -> node_5.in after 1 sec;

    reaction(node_1.out) {=
        printf("Received after pipeline: %d\n", node_1.out->value);
    =}
}